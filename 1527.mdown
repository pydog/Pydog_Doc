##2262/1527全中断方式软件解码，支持所有振荡电阻##

> 现在报警加视频监控是个趋势，我们这段时间一直在研发这类产品（AVCMS）。产品要用到无线遥控进行布撤防，以及接收无线红外探测器、无线门磁等报警信息。显然用芯片去解码有些不现实了，只能用软件做。

---

> 以前没有做过这方面的东西，于是上网搜索，看能不能下载到源程序,结果没有我想要的。我的MCU不仅要做软件解码，还要做其它事情，这必须用中断方式，而且不能延时。
  我找到的一种代码就是简单的循环判断，显然你不能再做其它事情了。而另一种代码号称中断方式，实际上就是把循环判断全部放到中断里，只要有一个中断，就在中断里接收完所有数据。这其实和第一种没什么区别，就是个伪中断。
  网上所有的程序都要固定发射端振荡电阻，从而数据的时间也是固定的，解码通过比较时间来得到数据。而我希望我们的产品能够适应所有的按照2262/1527格式发送数据的无线设备，这些设备可能来自不同厂家，它们的振荡电阻不可能一样，判断信号时间显然不行。

---

 > 分析2262/1527文档可发现:

 1. *同步头  高电平时间是4α,低电平时间是124α  总时间128α*

 2. *数据    短时间是4α，长时间是12α  总时间是16α*

 3. *同步头的总时间是数据总时间的8倍*

---

> 我的方案是利用STC的CCP功能，在信号的下降沿中断得到一个高电平时间，存入Recv.SigHigh，在信号的上升沿中断得到一个低电平时间，暂存到Temp。显然 Temp + Recv.SigHigh 就是一个同步头/数据的总时间。

>   + 如果这个信号就是同步头,它的总时间/8就是数据的总时间，我们再±25%，并存入Recv.SigL和Recv.SigH，后面32位数据的总时间必然都在[Recv.SigL,Recv.SigH]范围内，我们只需要将数据的高电平时间和低电平时间比较就能判断数据是“1”还是“0”了。

>   + 如果这个信号不是同步头，那么在后面的32位数据接收中，一定有一个数据的总时间不在[Recv.SigL,Recv.SigH]范围内。我们可以重新开始，拿这个总时间当做是同步头，继续接收数据。
   接收到24位数据，将数据存入DATA数据，并置RecvSuccFlag标志。主循环程序一定要在128α+16α×32 = 640α时间内取走数据，这个时间最短也有十几毫秒，应该够干些别的事情了。
   
---  

>   本方案只用了加减法和移位，没有乘除法，因此中断所用时间不长，但使用时还是要注意计算中断所占CPU时间。如果MCU速度较低，还要注意中断运算时间不要超过4α，测试时可以在中断开始和结束控制某个端口变化，从而得到中断运行时间。

